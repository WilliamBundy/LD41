const char* GL33_frag = "" "#version 330\n"
"in vec2 fPos;\n"
"in vec2 fTexture;\n"
"in vec2 fTextureScale;\n"
"in vec4 fColor;\n"
"flat in int fFlags;\n"
"out vec4 gColor;\n"
"uniform sampler2D uTexture; \n"
"uniform vec4 uTint; \n"
"uniform vec2 uInvTextureSize;\n"
"float median(float a, float b, float c)\n"
"{\n"
"	return max(min(a, b), min(max(a, b), c));\n"
"}\n"
"vec2 subpixelAA(vec2 pixel, vec2 zoom)\n"
"{\n"
"	vec2 uv = floor(pixel) + 0.5;\n"
"    uv += 1.0 - clamp((1.0 - fract(pixel)) * zoom, 0.0, 1.0);\n"
"	return uv;\n"
"}\n"
"void main()\n"
"{\n"
"	vec4 baseColor = fColor;\n"
"	if((fFlags & (1<<14)) > 0) {\n"
"		vec2 msdfUnit = 8 * uInvTextureSize;\n"
"		vec2 uv = subpixelAA(fTexture, fTextureScale) * uInvTextureSize;\n"
"		vec4 sdfVal = texture2D(uTexture, uv);\n"
"		float sigDist = median(sdfVal.r, sdfVal.g, sdfVal.b) - 0.5;\n"
"		sigDist *= dot(msdfUnit, 0.5/fwidth(uv));\n"
"		float opacity = clamp(sigDist + 0.5, 0.0, 1.0);\n"
"		baseColor *= vec4(1, 1, 1, opacity) * uTint;\n"
"		//baseColor = vec4(0.5/fwidth(uv), 1, 1);\n"
"	} else if(!((fFlags & (1<<5)) > 0)) {\n"
"		vec2 uv = subpixelAA(fTexture, fTextureScale);\n"
"		baseColor *= texture(uTexture, uv * uInvTextureSize);\n"
"	}\n"
"	gColor = baseColor;\n"
"	if((fFlags & (1<<10)) > 0) {\n"
"		vec2 dl = fPos - vec2(0.5, 0.5);\n"
"		//dist^2 = mag^2 - (0.5)^2\n"
"		float dist2 = dot(dl, dl) - 0.25;\n"
"		if(dist2 > 0) {\n"
"			gColor = vec4(0, 0, 0, 0);\n"
"		}\n"
"	}\n"
"}\n"
;
const char* GL33_vert = "" "#version 330\n"
"layout(location=0) in int vFlags; \n"
"layout(location=1) in vec4 vColor;\n"
"layout(location=2) in vec3 vPos; \n"
"layout(location=3) in vec2 vSize; \n"
"layout(location=4) in vec2 vCenter; \n"
"layout(location=5) in vec4 vTexture; \n"
"layout(location=6) in float vAngle;\n"
"out vec2 fPos;\n"
"out vec2 fTexture; \n"
"out vec2 fTextureScale;\n"
"out vec4 fColor;\n"
"flat out int fFlags;\n"
"uniform vec2 uOffset;\n"
"uniform vec2 uViewport;\n"
"uniform float uScale;\n"
"float[4] corners = float[4](-0.5, -0.5, 0.5, 0.5); \n"
"float[9] offsetX = float[9](0.0, 0.5, 0.0, -0.5, -0.5, -0.5,  0.0,  0.5, 0.5); \n"
"float[9] offsetY = float[9](0.0, 0.5, 0.5,  0.5,  0.0, -0.5, -0.5, -0.5, 0.0); \n"
"void main() \n"
"{ \n"
"	if((vFlags & 0x10) > 0) {\n"
"		gl_Position = vec4(0, 0, 0, 0); \n"
"		fTexture = vec2(0, 0); \n"
"		fColor = vec4(0, 0, 0, 0);\n"
"		fFlags = 0x20;\n"
"		return; \n"
"	} \n"
"	\n"
"	fColor = vColor.wzyx;\n"
"	fFlags = vFlags;\n"
"	int vx = gl_VertexID & 2; \n"
"	int vy = ((gl_VertexID & 1) << 1) ^ 3; \n"
"	int anchor = vFlags & 0xF;\n"
"	vec2 size = vSize; \n"
"	vec2 pos = vec2(corners[vx], corners[vy]);\n"
"	fPos = pos + vec2(0.5, 0.5);\n"
"	pos += vec2(offsetX[anchor], offsetY[anchor]);\n"
"	\n"
"	if((vFlags & (1<<6)) > 1) {\n"
"		pos = vec2(-pos.y, pos.x); \n"
"		size.xy = size.yx;\n"
"	} \n"
"	if((vFlags & (1<<7)) > 1) {\n"
"		pos = vec2(pos.y, -pos.x); \n"
"		size.xy = size.yx;\n"
"	} \n"
"	pos *= size; \n"
"	vec2 rot = vec2(cos(vAngle), sin(vAngle));\n"
"	mat2 rotmat = mat2(\n"
"			rot.x, rot.y,\n"
"			-rot.y, rot.x);\n"
"	pos -= vCenter;\n"
"	pos = rotmat * pos;\n"
"	pos += vCenter;\n"
"	pos += vPos.xy;\n"
"	pos.y -= vPos.z;\n"
"	pos -= uOffset;\n"
"	pos *= uScale; \n"
"	vec2 normalPos = pos * vec2(2, -2) / uViewport - vec2(1, -1);\n"
"	gl_Position = vec4(normalPos, 0, 1);\n"
"	vec4 texVec = vec4(vTexture.xy, vTexture.xy + vTexture.zw); \n"
"	if((vFlags & (1<<8)) > 1) {\n"
"		texVec.xyzw = texVec.zyxw; \n"
"	} \n"
"	if((vFlags & (1<<9)) > 1) {\n"
"		texVec.xyzw = texVec.xwzy; \n"
"	} \n"
"	float[4] texCoords = float[4](\n"
"			texVec.x, texVec.y,\n"
"			texVec.z, texVec.w); \n"
"	fTexture = vec2(texCoords[vx], texCoords[vy]); \n"
"	fTextureScale = (uScale * vSize) / vTexture.zw;\n"
"} \n"
;
